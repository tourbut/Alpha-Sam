# v1.1.0 Architecture Design Draft: Social Features & Data Integrity

**Status**: Draft
**Author**: Architect Agent
**Date**: 2026-01-19

## 1. 개요 (Overview)
v1.1.0의 핵심 목표는 **Social Features(팔로우, 공유, 리더보드)** 도입과 **데이터 무결성(Transaction-Position)** 강화입니다. 본 문서는 이에 대한 상세 스키마 설계와 아키텍처 의사결정을 기술합니다.

---

## 2. Social Features Schema Design

### 2.1 UserFollow (사용자 팔로우)
사용자 간의 단순 구독 모델(One-way Follow)을 지원합니다.

* **Table Name**: `user_follows`
* **Model Strategy**: M:N Relationship Resolving Table

| Column Name | Type | Constraints | Description |
|---|---|---|---|
| `follower_id` | UUID | FK(User.id), PK(Composite) | 팔로우를 하는 사용자 |
| `following_id` | UUID | FK(User.id), PK(Composite) | 팔로우 대상 사용자 |
| `created_at` | DateTime | Default(Now) | 팔로우 시점 |

* **Constraints**:
    * `Unique(follower_id, following_id)`: 중복 팔로우 방지.
    * `Check(follower_id != following_id)`: Self-follow 방지.
* **Access Pattern**:
    * "내가 팔로우한 사람": `SELECT * FROM user_follows WHERE follower_id = :me`
    * "나를 팔로우한 사람": `SELECT * FROM user_follows WHERE following_id = :me`

### 2.2 PortfolioShare (포트폴리오 공유)
포트폴리오 단위의 공개 범위를 제어합니다.

* **Table Name**: `portfolio_shares` (or extend `Portfolio` table)
    * *Decision*: `Portfolio` 테이블에 컬럼을 추가하는 대신 1:1 확장을 선택 (Reason: 관심사 분리 및 Optional 속성).

| Column Name | Type | Constraints | Description |
|---|---|---|---|
| `portfolio_id` | UUID | FK(Portfolio.id), PK | 대상 포트폴리오 |
| `visibility` | Enum | 'PRIVATE', 'PUBLIC', 'LINK_ONLY' | 공개 범위 설정 |
| `share_token` | UUID | Nullable, Indexed | 링크 공유용 토큰 |
| `copy_count` | Integer | Default(0) | 다른 유저가 참고/복사한 횟수 (Future) |
| `updated_at` | DateTime | | 설정 변경 시각 |

* **Logic**:
    * `PUBLIC`: 리더보드 등에서 누구나 상세 내역 조회 가능.
    * `LINK_ONLY`: `/share/{share_token}` 링크를 통해서만 접근 가능.
    * `PRIVATE`: 소유자만 접근 가능 (Default).

### 2.3 Leaderboard (리더보드)
리더보드는 실시간/준실시간 랭킹을 제공하며, 고성능 조회를 위해 **Redis**를 주 저장소로 활용합니다.

* **Storage**: Redis Sorted Set (ZSET)
* **Key Strategy**: `leaderboard:{period}` (e.g., `leaderboard:weekly`)
    * **Score**: 수익률 (PnL Percentage * 100, 소수점 처리)
    * **Member**: `user_id` (단순 ID 저장)
* **Metadata Cache**:
    * 리더보드 목록 조회 시 닉네임, 프로필 등을 DB에서 매번 긁어오면 부하가 심함.
    * 별도 Hash Key에 사용자 요약 정보 캐싱.
    * Key: `user:summary:{user_id}`
    * Field: `nickname`, `main_portfolio_pnl`, `avatar_url`

---

## 3. Data Integrity: Transaction vs Position

### 3.1 Problem Statement
* `Transaction`은 모든 변경 이력을 담고 있는 **Source of Truth**입니다.
* `Position`은 현재 보유 상태를 나타내는 **Snapshot**입니다.
* 문제: `Transaction`이 추가/수정될 때 `Position`과의 불일치(Inconsistency)가 발생할 수 있음. 매번 집계(Aggregation)를 하면 조회 성능(O(N)) 저하.

### 3.2 Architectural Decision
**"Hybrid Approach (Write-through Snapshot)"**를 채택합니다.

1. **Transaction is the Source of Truth**:
    * 데이터 복구, 감사(Audit), PnL 히스토리 계산의 기준은 오직 `Transaction` 테이블입니다.
2. **Position is a Materialized View (Table)**:
    * 조회 성능(O(1))을 위해 `Position` 테이블을 물리적으로 유지합니다.
3. **Atomic Updates (Strong Consistency)**:
    * `Transaction` 생성과 `Position` 업데이트는 **반드시 하나의 DB Transaction** 내에서 원자적으로 수행되어야 합니다.
    * *Application Logic Level*: Service Layer에서 `create_transaction` 메서드가 `update_position`을 호출하고 commit.

### 3.3 Implementation Guideline (Backend)
```python
async def create_transaction(session, data):
    async with session.begin():
        # 1. Transaction 레코드 생성
        new_tx = Transaction(**data)
        session.add(new_tx)
        
        # 2. Position 갱신 (Locking 고려: select for update)
        position = await get_position_for_update(session, data.portfolio_id, data.asset_id)
        if not position:
            position = create_new_position(...)
        
        # 3. 로직 적용 based on BUY/SELL
        if data.type == 'BUY':
             position.quantity += data.quantity
             position.avg_price = calculate_new_avg(...)
        elif data.type == 'SELL':
             position.quantity -= data.quantity
             # 실현 손익 계산 등 추가 로직
        
        session.add(position)
    # Commit happens here automatically
```

---

## 4. API Specification Draft

### 4.1 Social API
| Method | Endpoint | Description | Auth |
|---|---|---|---|
| `POST` | `/api/v1/social/follow/{user_id}` | 특정 유저 팔로우 | Required |
| `DELETE` | `/api/v1/social/follow/{user_id}` | 팔로우 취소 | Required |
| `GET` | `/api/v1/social/followers` | 나를 팔로우한 목록 | Required |
| `GET` | `/api/v1/social/following` | 내가 팔로우한 목록 | Required |

### 4.2 Leaderboard API
| Method | Endpoint | Description | Auth |
|---|---|---|---|
| `GET` | `/api/v1/leaderboard` | 상위 랭킹 조회 (Top 100) | Optional |
| `GET` | `/api/v1/leaderboard/me` | 내 랭킹 조회 | Required |

### 4.3 Portfolio Share API
| Method | Endpoint | Description | Auth |
|---|---|---|---|
| `PUT` | `/api/v1/portfolios/{id}/visibility` | 공개 범위 설정 변경 | Owner Only |
| `GET` | `/api/v1/portfolios/{share_token}/view` | 공유된 포트폴리오 조회 (Read-only) | Public |
