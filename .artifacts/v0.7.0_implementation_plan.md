# Implementation Plan - v0.7.0 (Multi-tenancy & Notifications)

## 개요
v0.7.0은 사용자별 데이터 격리(Multi-tenancy)를 위한 데이터베이스 구조 변경과 비동기 이메일 알림(Notification) 시스템 도입을 목표로 합니다.
이 문서는 `v0.7.0_specs.md`를 바탕으로 구체적인 작업 단계와 검증 방법을 정의합니다.

## Phase 1: DB Schema & Multi-tenancy Support
**목표:** `Position`과 `Transaction` 테이블에 소유권 정보를 명시하고, 데이터 무결성을 위한 스키마를 변경합니다.

### 1.1 마이그레이션 스크립트 작성 및 적용
- **작업**: Alembic을 사용하여 DB 마이그레이션 파일 생성.
- **스크립트 내용**:
  - `users` 테이블에 Default Admin 유저가 없으면 생성하는 로직 포함 (Migration 중 데이터 보정을 위해).
  - `positions` 테이블: `owner_id` 컬럼 추가(FK), 기존 데이터는 Default Admin ID로 업데이트, `(owner_id, asset_id)` Unique Index 추가.
  - `transactions` 테이블: `owner_id` 컬럼 추가(FK), 기존 데이터 Default Admin ID로 update.
- **파일명**: `alembic/versions/{date}_add_owner_id_to_transaction_position.py`

### 1.2 SQLModel 변경 (`src/models`)
- `src/models/position.py`: `owner_id` 필드 추가, `SQLModel` 메타데이터 업데이트.
- `src/models/transaction.py`: `owner_id` 필드 추가.
- `src/models/asset.py`: 기존 `owner_id` 필드의 의미(NULL=Global) 주석 강화 및 검증 로직 확인.

### 1.3 CRUD Layer 수정 (`src/crud`)
- **원칙**: 모든 사용자 데이터 접근 시 `owner_id` 필터를 강제해야 함.
- **수정 대상**:
  - `crud_position.py`: `get_multi`, `create` 등의 메서드에 `owner_id` 인자 필수화.
  - `crud_transaction.py`: `get_multi_by_owner` 등으로 변경.
  - `crud_asset.py`: `get_assets` 시 (Global Assets OR My Custom Assets) 로직 구현.

### 1.4 Notification Settings Schema
- **테이블명**: `notification_settings`
- **컬럼**:
  - `id`: PK
  - `user_id`: FK (`users.id`), Unique
  - `daily_report_enabled`: Boolean (Default: True)
  - `price_alert_enabled`: Boolean (Default: True)
  - `created_at`, `updated_at`
- **관계**: `User`와 1:1 관계. User 생성 시 자동 생성되거나, 조회 시 없으면 생성.

## Phase 2: Celery & Redis Infrastructure
**목표:** 비동기 작업 처리를 위한 인프라와 Worker를 구성합니다.

### 2.1 환경 설정 및 의존성
- **Docker Compose**: `docker-compose.yml` 및 `docker-compose.prod.yml`에 `redis`, `celery_worker`, `celery_beat` 서비스 추가.
- **Config**: `src/core/config.py`에 `CELERY_BROKER_URL`, `CELERY_RESULT_BACKEND` 설정 추가.
- **Dependencies**: `pyproject.toml` (또는 `requirements.txt`) 에 `celery`, `redis` 등 추가.

### 2.2 Celery App 설정
- **파일**: `src/core/celery_app.py` (신규) 또는 `src/worker.py`
- **내용**: Celery 인스턴스 초기화, Task 모듈 로딩 설정.

## Phase 3: Email Notification System
**목표:** 이메일 발송을 위한 서비스 레이어와 템플릿을 구현합니다.

### 3.1 Email Service Layer
- **파일**: `src/services/email_service.py` (신규)
- **기능**:
  - `smtplib`를 이용한 이메일 발송 유틸리티.
  - Jinja2 템플릿 렌더링 (HTML 본문 생성).
  - 환경변수에서 SMTP 정보(`SMTP_HOST`, `SMTP_PORT`, `SMTP_USER`, `SMTP_PASSWORD`) 로드.

### 3.2 HTML Templates
- **경로**: `src/templates/email/`
- **파일**:
  - `base.html`: 공통 스타일/헤더/푸터.
  - `price_alert.html`: 목표가 도달 알림 템플릿.
  - `daily_report.html`: 일일 수익률 리포트 템플릿.

### 3.3 Settings API
- **Endpoint**: `/api/v1/users/me/settings`
- **Method**:
  - `GET`: 현재 설정 조회.
  - `PUT` (or `POST`): 설정 업데이트.
- **Payload (Request)**:
  ```json
  {
    "daily_report_enabled": true,
    "price_alert_enabled": false
  }
  ```
- **Response**:
  ```json
  {
    "user_id": 1,
    "daily_report_enabled": true,
    "price_alert_enabled": false
  }
  ```

## Phase 4: Feature Logic & Integration
**목표:** 실제 비즈니스 로직에 알림 기능을 연동합니다.

### 4.1 Tasks 구현
- **파일**: `src/tasks/email_tasks.py` (신규)
- **Tasks**:
  - `send_price_alert_email(user_id, asset_info)`
  - `send_daily_report_email(user_id, report_data)`
  - `daily_portfolio_report_job()`: 전체 유저 루프 돌며 리포트 생성 및 발송 태스크 trigger.

### 4.2 Trigger Point 연동
- **가격 알림**: `src/services/market_service.py` (또는 Price Update 로직)에서 가격 변동 시 `check_alerts` 로직 수행 -> `send_price_alert_email` 태스크 발행.
  - *Policy*: 자산별 1일 1회 발송 제한 (Redis Key 활용).
- **스케줄러**: `Celery Beat` 설정에 `daily_portfolio_report_job`을 매일 09:00 KST 등록.

## 검증 계획 (Verification Plan)

### Automated Tests
1. **Migration Test**: 빈 DB에서 `alembic upgrade head` 실행 성공 확인.
2. **Schema Test**: `Position` 중복 생성 시도 시 Unique Constraint Violation 발생 확인.
3. **Task Test**: Celery Task 호츨 시(Eager mode) 로직 정상 수행 확인.

### Manual Verification
1. **Multi-tenancy**:
   - Swagger UI로 User A와 User B로 각각 로그인.
   - User A가 생성한 Position이 User B 조회 시 나타나지 않아야 함.
2. **Email**:
   - (로컬 개발 시) Docker Logs에서 Celery Worker가 Task를 수신하고 처리하는지 확인.
   - 실제 이메일 발송 또는 Mock 처리된 로그 확인.
